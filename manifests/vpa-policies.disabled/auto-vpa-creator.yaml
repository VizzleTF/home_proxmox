# CronJob для автоматического создания VPA объектов для всех workload'ов
apiVersion: batch/v1
kind: CronJob
metadata:
  name: auto-vpa-creator
  namespace: vpa-system
spec:
  schedule: "*/5 * * * *" # Каждые 5 минут
  jobTemplate:
    spec:
      template:
        spec:
          serviceAccountName: vpa-auto-creator
          containers:
          - name: vpa-creator
            image: bitnami/kubectl:latest
            command:
            - /bin/bash
            - -c
            - |
              #!/bin/bash
              echo "=== Auto VPA Creator started ==="
              
              # Функция проверки системных namespace'ов
              is_system_namespace() {
                local namespace=$1
                # Расширенный список системных namespace'ов
                local system_namespaces=(
                  "kube-system"
                  "kube-public" 
                  "kube-node-lease"
                  "vpa-system"
                  "longhorn-system"
                  "metallb-system"
                  "cert-manager"
                  "ingress-nginx"
                  "external-dns"
                  "default"
                )
                
                for sys_ns in "${system_namespaces[@]}"; do
                  if [[ "$namespace" == "$sys_ns" ]]; then
                    return 0  # true - это системный namespace
                  fi
                done
                return 1  # false - не системный namespace
              }
              
              # Функция получения специфичных лимитов ресурсов
              get_resource_limits() {
                local namespace=$1
                local workload_name=$2
                
                # Специальные настройки для разных приложений
                case "$namespace:$workload_name" in
                  "nextcloud:nextcloud")
                    echo "50m 2 512Mi 4Gi"  # min_cpu max_cpu min_mem max_mem
                    ;;
                  "nextcloud:nextcloud-postgresql")
                    echo "25m 1 256Mi 2Gi"
                    ;;
                  "keycloak:keycloak")
                    echo "25m 2 512Mi 2Gi"
                    ;;
                  "keycloak:keycloak-postgresql")
                    echo "25m 500m 128Mi 1Gi"
                    ;;
                  "n8n-system:n8n")
                    echo "25m 1 256Mi 2Gi"
                    ;;
                  "database-system:"*)
                    echo "15m 500m 64Mi 1Gi"
                    ;;
                  "pihole-system:pihole")
                    echo "15m 200m 128Mi 512Mi"
                    ;;
                  "vaultwarden:vaultwarden")
                    echo "15m 200m 128Mi 512Mi"
                    ;;
                  *)
                    # Стандартные лимиты для остальных приложений
                    echo "10m 1 32Mi 2Gi"
                    ;;
                esac
              }
              
              # Функция создания VPA для deployment
              create_vpa_for_workload() {
                local namespace=$1
                local workload_type=$2
                local workload_name=$3
                
                # Строгая проверка системных namespace'ов
                if is_system_namespace "$namespace"; then
                  echo "Skipping system namespace: $namespace"
                  return
                fi
                
                # Дополнительная проверка на namespace'ы начинающиеся с kube-
                if [[ "$namespace" =~ ^kube- ]]; then
                  echo "Skipping kubernetes system namespace: $namespace"
                  return
                fi
                
                # Создаем имя VPA в lowercase согласно RFC 1123
                local vpa_name="auto-$(echo "$workload_type" | tr '[:upper:]' '[:lower:]')-${workload_name}-vpa"
                
                # Проверяем, существует ли уже VPA
                if kubectl get vpa "$vpa_name" -n "$namespace" >/dev/null 2>&1; then
                  echo "VPA $vpa_name already exists in namespace $namespace"
                  return
                fi
                
                # Получаем специфичные лимиты для данного приложения
                local limits=($(get_resource_limits "$namespace" "$workload_name"))
                local min_cpu=${limits[0]}
                local max_cpu=${limits[1]}
                local min_mem=${limits[2]}
                local max_mem=${limits[3]}
                
                echo "Creating VPA for $workload_type/$workload_name in namespace $namespace (limits: $min_cpu-$max_cpu CPU, $min_mem-$max_mem Memory)"
                
                # Создаем VPA
                cat <<EOF | kubectl apply -f -
              apiVersion: autoscaling.k8s.io/v1
              kind: VerticalPodAutoscaler
              metadata:
                name: $vpa_name
                namespace: $namespace
                labels:
                  auto-created: "true"
                  workload-type: "$(echo "$workload_type" | tr '[:upper:]' '[:lower:]')"
                  workload-name: "$workload_name"
              spec:
                targetRef:
                  apiVersion: apps/v1
                  kind: $workload_type
                  name: $workload_name
                updatePolicy:
                  updateMode: "Auto"
                resourcePolicy:
                  containerPolicies:
                  - containerName: "*"
                    minAllowed:
                      cpu: $min_cpu
                      memory: $min_mem
                    maxAllowed:
                      cpu: $max_cpu
                      memory: $max_mem
                    controlledResources:
                      - cpu
                      - memory
              EOF
              }
              
              # Обрабатываем все Deployment'ы
              echo "Processing Deployments..."
              kubectl get deployments --all-namespaces -o jsonpath='{range .items[*]}{.metadata.namespace}{" "}{.metadata.name}{"\n"}{end}' | while read namespace name; do
                if [[ -n "$namespace" && -n "$name" ]]; then
                  create_vpa_for_workload "$namespace" "Deployment" "$name"
                fi
              done
              
              # Обрабатываем все StatefulSet'ы
              echo "Processing StatefulSets..."
              kubectl get statefulsets --all-namespaces -o jsonpath='{range .items[*]}{.metadata.namespace}{" "}{.metadata.name}{"\n"}{end}' | while read namespace name; do
                if [[ -n "$namespace" && -n "$name" ]]; then
                  create_vpa_for_workload "$namespace" "StatefulSet" "$name"
                fi
              done
              
              # Обрабатываем все DaemonSet'ы
              echo "Processing DaemonSets..."
              kubectl get daemonsets --all-namespaces -o jsonpath='{range .items[*]}{.metadata.namespace}{" "}{.metadata.name}{"\n"}{end}' | while read namespace name; do
                if [[ -n "$namespace" && -n "$name" ]]; then
                  create_vpa_for_workload "$namespace" "DaemonSet" "$name"
                fi
              done
              
              echo "=== Auto VPA Creator completed ==="
            resources:
              requests:
                cpu: 50m
                memory: 64Mi
              limits:
                cpu: 200m
                memory: 256Mi
          restartPolicy: OnFailure
---
# ServiceAccount для auto-vpa-creator
apiVersion: v1
kind: ServiceAccount
metadata:
  name: vpa-auto-creator
  namespace: vpa-system
---
# ClusterRole для создания VPA объектов
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: vpa-auto-creator-role
rules:
- apiGroups: [""]
  resources: ["namespaces"]
  verbs: ["get", "list"]
- apiGroups: ["apps"]
  resources: ["deployments", "statefulsets", "daemonsets"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["autoscaling.k8s.io"]
  resources: ["verticalpodautoscalers"]
  verbs: ["get", "list", "create", "update", "patch", "delete"]
---
# ClusterRoleBinding для auto-vpa-creator
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: vpa-auto-creator-binding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: vpa-auto-creator-role
subjects:
- kind: ServiceAccount
  name: vpa-auto-creator
  namespace: vpa-system 